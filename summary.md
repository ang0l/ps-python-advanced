# Продолжаю изучать Python

Начало моего обучения - <a href="https://github.com/ang0l/ps-python-basic">Основы Python</a>

## Раздел 1. Введение

### Продвинутый Python

1. **Предпосылки и подготовка**
   - Этот курс расположен между основами Python и изучением HTTP-фреймворков.
   - Требуются базовые знания Python: переменные, циклы, условия, функции.
   - Знания о объектно-ориентированном программировании (ООП) и управлении зависимостями изучаются в этом курсе.
2. **Цели курса**
   - Понимание принципов ООП и SOLID.
   - Изучение асинхрнности и внутренней работы Python.
3. **Темы курса**
   - Принципы SOLID и их применение.
   - Асинхронность и Event Loop в Python.
   - Управление зависимостями, проектирование и создание архитектуры проектов.
   - Использование библиотеки typing и декораторов.
4. **Значимость Python**
   - Широкое применение Python в ML и бэкенде.
   - Рост популярности языка благодаря его возможностям в AI и бэкенд-разработке.
5. **Целевая аудитория**
   - Эти лекции предназначены для тех, кто уже знаком с основами Python и стремится углубить свои знания.

Курс обеспечит более глубокое понимание работы Python и познакомит с навыками, необходимыми для дальнейшей работы с
фреймворками и сложными проектами.

### Как устроен курс

Курс по объектно-ориентированному программированию на Python состоит из 12 модулей и 6 частей. Структура курса содержит
определенные этапы.

1. **Введение и настройка окружения**
   - Первый модуль - введение.
   - Настройка окружения для работы с Python. Возможно пропустить, так как у меня уже есть базоыве настройки.
2. **Объектно-ориентированное программирование (ООП)**
   - Изучение классов, объектов и основ ООП.
   - Изучение декораторов и их применение в Python.
3. **Принципы SOLID и рефакторинг**
   - Изучение принципов SOLID.
   - Практическое применение принципов на примерах.
4. **Работа под капотом Python**
   - Погружение в детали работы Python, включая стек фреймов, байт-код и garbage collector.
5. **Generic и типизация**
   - Применение generic в методах и классах.
   - Изучение пакета typeing для сложных приложений.
6. **Асинхронное программирование**
   - Принципы асинхронного программирования и его отличие от параллельоного выполнения.
   - Практические задачи по оптимизации приложений.
7. **Внешние зависимости и Poetry**
   - Управление зависимостями с помощью Poetry.
   - Структурирование пакетов в Python и создание проекта.
8. **Textual и архитектура проекта**
   - Построение консольных интерфесов и изучение основ проектирования и архитектуры.

В дополнение к теоретической части курса я буду писать код, выполнять упражнения и участвовать в практических заданиях
для закрепления материала. В курсе доступны AI-функции, включая домашние задания и занятия с наставником.

### Обзор проекта

В рамках данного курса я создам проект - базу знаний, аналог Obsidian, работающий с файловой системой и потенциально с
базой данных или внешним API.

#### Основные этапы проекта

1. **Структура проекта**
   - Разработка астракции для взаимодействия с файлами и заметками.
   - Возможность подлючения различных хранилищ данных.
2. **Функции приложения**
   - Хранение заметок в формате Markdown в папках.
   - Навигация по дереву папок и файлов.
   - Просмотр и редактирование заметок.
3. **Технологии**
   - Применение объектно-ориентированного программирования (ООП) с использование Textual для создания консольного
     приложения.
   - Работа с виджетами, взаимодействие с приложениями через мышь и клавиатуру.
4. **Дополнительыне возможности**
   - Импорт заметок через URL, что позволяет интегрировать веб-страницы в базу
5. **Навыки**
   - Усвоение принципов архитектуры программ, абстракция от конкретного хранилища данных.
   - Практика работы с продвинутыми функциями Python, ООП и асинхронным программированием.

В конце курса у меня будет готовй проект, который можно развивать и делиться им с друзьями.

## Раздел 2. Настройка окружения

### Настройка окуржения

Для успешного прохождения курса мне понадобятся неекоторые инструменты.

1. **Редактор кода**
   - Я буду использовать Visual Studio Code (VS Code), так как она бесплатный и доступен для всех платформ.
   - Но можно выбрать другой редактор, например, PyCharm или Sublime Text.
2. **Git-клиент**
   - Необязателен, но полезен для сравнения кода.
   - Репозиторий с уроками будет доступен, что позволи переходить между уроками.
   - Можно использовать консольный Git или клиентский интерфейс, например Fork (бесплатный с возможностью покупки).
3. **Терминал**
   - Можно использовать встроенный терминал операционной системы или, например, Alacrity.
   - Для базовых оперций пойдет терминал в VS Code.
4. **Python**
   - Необходим Python-рантайм.
   - Установка и обновление Ptyhon будут обсуждаться в отдельных лекциях.

Для начинающих же достаточно установить Visual Studio Code и Python, чтобы начать писать код. Остальные инструменты
придатют больше гибколсти и удобства в работе, но не являются обязятельными.

### Установка Python Windows

1. **Методы установки Python на Windows**
   - Простая установка (рекомендовано для новичков):
     - загрузить пакет установки с официального сайта Python;
     - инсталлятор доступен для 64-битных, 32-битных и ARM64 архитектур;
     - запустить инсталлятор, используя опцию "Install Now".
   - PyEnvWin (для опытных пользователй):
     - поддержка изменения версий Python "на лету";
     - удобно для управления несколькими версиями Python для разных проектов.
2. **Процесс установки**
   - Перейти на сайт Python и скачать нужный инсталлятор для своей архитектуры.
   - Запустить установку и следовать инструкциям, нажимая "Install Now".
   - Установка включает стандартную библиотеку и интерпретатор Python.
3. **Проверка установки**
   - Открыть терминал (Command Prompt или Windows Terminal).
   - Ввести команду `py --version` для проверки установленной версии Python.
   - Рекомендуется использовать Windows Terminal вместо стандартного Command Prompt для работы с Python.
4. **Дополнительные лекции**
   - Отдельная лекция будет посвящена установке и использованию PyEnv для более продвинутого управления версиями
     Python.

Теперь я готов использовать Python на своем Windows компьютере!

### Pyenv

Не установился на моем компе, т.е. политика безопасности отключила выполнение скриптов в системе. Разбираться с этим
буду позже, если сильно приспичит. А пока изучаю курс дальше.

### Настройки VSCode

1. **Визуальные настройки**
   - Размер шрифта выбрал необходимый для удобной работы.
   - Семейство шрифтов: установил JetBrains Mono, доступный бесплатно на сфте JetBrains.
   - Тема: Purple School Scene, доступна в магазине расширений.
   - Иконки: установил Material Icon Scene для симпатичного отображения в панели.
2. **Основные расширения**
   - **Python Extension от Microsoft**:
     - поддержка синтаксиса Python;
     - форматирование и работа с виртуальными окружениями.
   - **Python Debugger**:
     - для отладки Python-кода.
3. **Дополнительные сведения**
   - Установлен Python, доступный в терминале Visual Studio Code.
   - Установленные расширения обеспечат полную функциональность для работы с Python в Visual Studio Code.

Следуя этим инструкциям, у меня будет оптимальная среда для разработки на Python в Visual Studio Code.

## Раздел 3. Основы ООП

### Класс и экземпляр

Объектно-ориентированное программирование (ООП) в Python основывается на классах и их экземпелярах.

**Класс** - это шаблон или чертеж для создания объектов. Например, класс "Автомобиль" может содержать такие атрибуты,
как марка и модель. На его основе я можгу созавать конкретные автормобили, такие как Audi A6 или Mercedes GLE.

**Экземпляр** - это конкретный объект, созданный на основе класса. Экземпляр "Заметка" (например, None1) будет
содержать определенные данные, такие как заголовок и содержание.

**Атрибуты** - это данные, хранящиеся в классе. Напримпр, у класса "Стол" есть атрибуты высоты, ширины и материала.

**Методы** - это действия, которые можно выполнить с объектами. Они позволяют взаимодействовать с объектами внутри
класса.

В Python для объявления класса используется ключевое слово `class`. Например, `class Note` описывает, каким образом
будет представлена заметка.

Важной часть ООП является абстракция, которая позволяет описывать только те аспекты объекта, которые важны для моего
приложения.

Таким образом, классы делают программирование более интуитивным, соотвествующим реальному миру, позволяя легко
создавать и работать с объектами в коде.

### Пример класса

#### Подготовка рабочей среды

1. Создаю новую папку
2. Инициализирую git-репозиторий.
3. Открываю проект в редакторе Visual Studio Code.

#### Создание первого класса

1. Создаю файл `main.py`.
2. Определяю класс `User` с атрибутами `email`, `name` и `age`.
3. Указываю типы атрибутов: строка для `email` и `name`, число для `age`.

#### Создание экземпляров класса

1. Создаем экземпляры `userMaria` и `userAnton` через вызов контруктора класса `User`.
2. Проверяю тип экземпляра с помощью функции `tytp()`.

#### Работа с атрибутами экземпляров

1. Присваиваю значения атрибутам экземпляра через обращение к атрибутам (`userAnton.email = 'a@sobachka.ru`).
2. Читаю значения атрибутов, обращаясь к ним напрямую (`print(userAnton.email)`).

#### Ошибки и поиск атрибутов

1. Если атрибут не задан, попытка его чтения вызовет `AttributeError`.
2. При необходимости можно присвоить начальные значения атрибутам класса.

### Атрибуты

#### Что такое атрибуты

Атрибут - это переменная, принадлежащая объекту или классу, описывающая состояние объекта.

#### Типы атрибутов

**Атриут класса**: задается для класси и применяется ко всем его экземплярамю. Изменения в атрибуте класса отражаются
на всех экземплярах.

**Атрибут экземпляра**: задается для конкретного экземпляра, не зависит от изменений в классе.

#### Поиск атрибута

При обращении к атрибуту (например, `note.title`), Python ищет его сначала в экземпляре, затем в классе, и если не
нейден, тогда поиск идет в родительских классах. Если нигде не найден, возникает ошибка `AttributeError`.

#### Практический пример

1. **Создание класса автомобиля**: описываются марка, модель, год производства и тип транспортного средства.
2. **Создание экземпляра автомобиля**: присваивание значений атрибутам экземпляра и демонстрация того, как изменение
   атрибута класса влияет на экземлпяр.
3. **Изменение атрибутов**: влияние изменения атрибута класса на экземпляры.

### Методы

В этой лекции обсуждались методы в оьъектах программирования. Методы определяются внутри классов и отвечают за
действия, которые может выполнять объект. В отличие от атрибутов, которые хранят данные, методы описывают поведение
объектов.

#### Определение методов

1. Начинаются с ключевого слова `def`.
2. Первым аргументом всегда является `self`, ссылка на экземпляр объекта.
3. Методы могут принимать дополнительные аргументы и возвращать значения как функции.

#### Практический пример

1. Созается класс `Task` с атрибутами `done`(boolean) и `title` (строка).
2. Определяется метод `get_info`, который возвращает значение `title`.
3. Используется `self` для доступа к атрибутам экземпляра в методах.

#### Создание и использование метода

1. Создается экземпляр класса `Task`.
2. Вызывается метод `get_info` через экземпляр.
3. Определяется метод `set_info` для установки `title` при помощи `self`.

#### Взаимодействие с консолью

После заданрия занчения `title` вызывается метод для получения данных и печатается заголовок.

### Self

**Понятие self**: self - это ссылка на текущий обхект класса, используемая для взаимодействия с ним.

#### Механизм работы self

1. При вызове метода, например getInfo, под капотом ищется класс, из которого создан объект.
2. Метод вызывается с передачей ссылки на текущий экземпляр как первый аргумент.
3. Именно поэтому методы принимают экземпляр класса в качестве первого аргумента.

#### Пример с авторизацией

Создаем метод login в классе авторизации, где self изменяет свойство isAuth на True. Такой подход позволяет легко
управлять состоянием объекта, например, авторизовывать пользователя.

#### Альтернативные имена для self

Self — стандартное название, но допустимо использовать другое имя. Python-инструменты могут выдавать предупреждения при
использовании нестандартных имен.

#### Рекомендации:

Использовать self согласно стандартам Python для ясности и читаемости кода. Понимать, что self — это просто соглашение,
но его использование является хорошей практикой.

Таким образом, self обеспечивает возможность манипуляции с текущим объектом класса в методах, и его наименование в
качестве аргумента методов стало стандартом в Python.

### Init

#### Определение и назначепние

`__init__` - это специальный метод класса в Python, который автоматически вызывается при создании нового экземпляра
этого класса. Он не создает объект, а инициализирует его, настраивая свойства объекта.

#### Объявление

Обявляется с использованием двух нижних подчеркиваний: `__init__`. Первый параметр метода всегда `self`, он ссылается
на сам объект.

#### Как работает

Автоматичеки вызывается при создании экземпляра класса. Позволяет задать начальные значения для атрибутов объекта.
Может принимать дополнительные аргументы и использовать `*args` и `**kwargs` для динамического числа аргументов.

#### Пример использования

Без `__init__` мы бы вручную инициализировали каждый атрибут объекта после его создания. С `__init__`, мы передаем
необходимые значения сразу при создании объекта, например:

```
class Note:
    def __init__(self, title, description):
        self.title = title
        self.description = description

note = Note('Заметка', 'Это моя заметка')
```

#### Дополнительные возможности

Атрибуты могут иметь значения по умолчанию. Можно использовать классные переменные для задания дефолтных значений
атрибутов. `__init__` улучшает читаемость и безопасность кода, предупреждая забывание инициализации важных свойств.

#### Заключение

`__init__` делает процессы создания и инициализации экземпляров удобными, облегчая работу с объектами в Python.

### Упражнение - Герой

#### Структура класса Hero

1. **Свойства**:
   - `name` (строка): имя героя;
   - `hp` (целое число): по умолчанию 100;
   - `inventory` (список строк): пустой при инициализации;
   - `status` (булево): по умолчанию `True`.
2. **Методы**:
   - `take_damage(damage: int)`: уменьшает hp героя на величину amount. Если hp становится меньше или равным 0,
     герой умирает (`self.status = False`);
   - `heal(heal: int)`: увеличивает hp героя на величину amount, но не более 100. Если герой мертв, лечение не
     проводится;
   - `add_item(self, item: str)`: добавляет строковый элемент в инвентарь героя;
   - `show_status()`: выводит текущий статус героя, включая имя, hp, списот инвентаря и статус (жив/мертв).

#### Пример использования

1. Создание героя с именем "Андрей".
2. Добавление предмета "Меч" в инвентарь.
3. Вывод статуса героя.
4. Нанесение урона 30, затем 60
5. Лечение на 50 hp.
6. Повторный вывод статуса.
7. (Опционально) Дальнейшее нанесение урона для проверки условий сметри героя.
8. (Опционально) Проверка статуса после нанесения смертельного урона
9. (Опционально) Нанесение урона для проверки вывода сообщения, что герой УЖЕ повержен.

Это упражнение помогает попрактиковаться в использовании методов и свойств класса, а также демонстрирует основы
создания игровой механики.

### Статические методы

Статические методы - это методы внутри класса, которые не зависят ни от самого класса, ни от его экземпляров. Они
выполняют функции, которые логически связаны с классом, но не требуют доступа к его состоянию. Чтобы куазать, что метод
статический, испльзуют декоратор `@staticmethod`.

#### Примеры использования

Вспомогательные методы: позволяют выполнять задачи, не зависящие от состояния объекта. Например, метод для вычисления
разницы лет между текущим годом публикации книги.

Утилитарные классы: группы логически связанных функций, не имеющих состояния, объединенные в класс для удобства.

#### Применение статических методов

Вызываются напрямую от класса, передавая необходимые аргументы. Используются в ситуациях, когда не требуется доступ к
данным конкретного экземпляра объекта.

#### Как это выглядит в коде

Объявляется класс.  
Определяется статический метод внутри класса с декоратором `@staticmethod`.  
Метод не принимает `self` и выполняет свою задачу, работая с переданными ему аргументами.  
Вызывается метод напрямую через имя класса.

Так как статические методы не имеют доступ к объекту, они служат для задач, которым не нужно состояние объектов, но
которые логически связаны с функциональностью класса.

### Классовый метод

В этой лекции я рассмотрел классовые методы в Python, которые занимают промежуточное положение между методами
экземпляра и статическими методами.

**Методы экземпляра** имеют доступ к атрибутам конкретного объекта, обозначаются аргументом `self`.

**Классовые методы**:

- имеют доступ к самому классу, но не к его истантсам, и обозначаются аргументом `cls`;
- полезны для работы с общими данными класса, например, подсчета количества созданных объектов;
- используются для создания альтернативных конструкторов, позволяющих создавать объекты не только стандартным путем.

**Статические методы** не имеют доступа ни к инстансам, ни к классу. Они просто находятся внутри класса как независимые
функции.

Пример использования классового метода: создание пользователя из стоки данных с помощью метода `from_string`, который
выступает как альтернативный конструктор.

### Встроенные (магические) методы

1. **Метод `__init__`**:
   - это встроенный метод для инициализации объекктов класса;
   - например, в классе `ShoppingList` я могу инициализировать пустой список покупок.
2. **Сравнение объектов**:
   - стандартное сравнение проверяет адреса в памяти;
   - для сравнения содержимого можно переопределить метод `__eq__`;
   - `__eq__` позволяет сравнивать объекты по содержимому, а не только по их местоплоложению в памяти.
3. **Вычисление длины**:
   - метод `__len__` используется для определения длины объекта;
   - Переопределив `__len__`, можно использовать стандартную функцию `len()` для получения длины списка покупок.
4. **Доступ по индексу**:
   - метод `__getitem__` позволяет обращаться к элементакм объекта по индексу;
   - полезен для получения элементов в стиле списка.
5. **Строковое представление**:
   - метод `__repr__` определяет, как объект будет представлен в виде строки;
   - полезен для логирования и отладки, поскольку позволяет выводить внятное строковое представление объекта при вызове
     `print()`.
6. **Расширяемость классов**:
   - переопределение магических методов позволяет использовать стандартные операторы и функции (например, сравнение и
     расчет длины);
   - осознание этих возможностей помогает сделать классы более гибкими и функциональными.

### Property

На этом уроке я изучил использование декоратора `@property` в Python для создания вычисляемых свойств у классов.

**Создание класса**: создается класс `Rectangle`, представляющий прямоугольник, с методами для инициализации ширины
(width) и высоты (height).

**Метод вычисления площади**: добавляется метод `area`, который вычисляет площадь прямоугольника, умножая ширину на
высоту.

**Проблема метода**: вызывая метод `area`, нужно использовать скобки, что не всегда удобно, когда хочется просто
получить значение.

**Решение с использованием декоратора**: применяется декоратор `@property`, чтобы сделать метод `area` свойством. Это
позволяет обращаться к площади как к обычному свойству класса без необходимости использовать скобки.

**Пример использования**: теперь можно получить значение площади, просто обратившись к `rect.area`, аналогично
свойствам `winth` и `height`.

Этот подход удобен, когда вычисляемые занчеиния проще восприниамаются как свойства объекта, а не как методы.

От себя: чем это отличается от инициализации этого же свойства при создании экземпляра?

### Dataclass

В этой лекции расказывается о ключевых преимуществах использования "датаклассов" в Python для упрощения работы с
классами.

**Проблема классического продхода**.  
В стандартном подходе необходимо вручную определять множество методов для класса (инициализация, вывод в строку,
сравнение и т.д.).

**Решение с датаклассами**  
Использование декоратора `@dataclass` позволяет автоматически генерировать необходимые методы, такие как `__init__`,
`__repr__`, `__eq__` и другие. Датаклассы импортируются из модуля `dataclasses`.

**Пример использования**

- Создается класс `Task` с полями `title`, `priority` (по умолчанию 3) и `done` (по умолчанию False).
- Декоратор `@dataclass` автоматически создает методы на основе объявленных полей.
- Пример создания объекта, вывода в консоль и сравнения объектов.

**Дополнительные возможности**  
Можно задавать поведение для дополнительных параметров: например, включать или отключать порядок сравнения,
использовать методы, такие как `__post_init__`, для дополнительных операций после инициализации.  
Возможность исключать поля из вывода или сравнения с помощью настройки полей (например,
`lield(repr=False, compare=False)`).

**Пост-инициализация и безопасные поля**  
Метод `__post_init__` позволяет задавать значения полей после инициализации класса. Поля можно делать "секретными",
чтобы исключить их из автоматического вывода в логах.

**Облегчение работы**  
Датаклассы существенно упрощают создание и управление классами, что делает код более читаемым и удобным в поддержке.

Заключение: датаклассы в Python позволяют сократить количество шаблонного кода и делают работу с объектами более
эффективной и простой.

## Раздел 4. Декораторы

### Что такое декоратор

#### Определение

Декоратор - это паттерн проектирования, позволяющий обернуть одну функцию в другую для модификации ее поведения. Python
предоставляет синтаксический сахар для декораторов через символ `@`.

#### Основная идея

Имеется функция `say_hello()`, которая выводит "Привет!". Нужно логировать каждый вызов этой функции, добавляя
сообщения о начале и завершении выполнения.

#### Создание простого декоратора

Создается функция `log()`, которая принимает другую функцию как аргумент. В этой функции создается внутреняя функция
`wrapper()`, которая:

- выводит "функция началась",
- вызывает исходную функцию,
- выводит "функция завершилась".

`wrapper()` возвращается как результат `log()`.

#### Использование декоратора

Оборачивается `say_hello()` в `log_decorator()` и сохраняется результат. Вызов обернутой функции приводит к выводу
сообщений о начале и коные, а также сообщения "Привет!".

#### Синтаксический сахар

Вместо ручного оборачивания функций, используйте символ `@` для декорации:

```
@log
def say_hello():
    pass
```

Это автоматически применяет декораток к функции.

#### Преимущества использования декораторов

Упрощение кода за счет улучшенной читаемости и легкости приенения декораторов. Возможность расширения функцинала без
изменения исходного кода функции.

#### Функциональные возможности

Декораторы могут выполнять различные задачи: логирование, аутентификация, кэширование и другое. Это достигается
благодаря обертыванию и модификации поведения исходной функции.

Используя декораторы, разработчики могут легко добавлять новые функциональные возможности к функциям без дублирования
кода и изменения их внутренней логики.
